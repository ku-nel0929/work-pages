<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>異体字・外字 画像アウトライン変換ツール</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/imagetracerjs/1.2.6/imagetracer.min.js"></script>
    <style>
        :root {
            --primary: #0f2350;
            --secondary: #c5a059;
            --bg: #f4f7f9;
            --text: #333;
        }
        body {
            font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            max-width: 900px;
            width: 100%;
            background: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        h1 {
            color: var(--primary);
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }
        .description {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 20px;
            background: #eef2f5;
            padding: 15px;
            border-radius: 4px;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        .file-input-wrapper {
            flex: 1;
        }
        input[type="file"] {
            display: block;
            width: 100%;
            padding: 10px;
            background: #fafafa;
            border: 1px dashed #ccc;
            border-radius: 4px;
            cursor: pointer;
        }
        .range-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            flex: 1;
            cursor: pointer;
        }

        /* Preview Area */
        .preview-area {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .preview-box {
            flex: 1;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            text-align: center;
            background: #fff;
            min-height: 250px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        .preview-label {
            position: absolute;
            top: 5px;
            left: 5px;
            background: #333;
            color: #fff;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 3px;
            opacity: 0.8;
        }
        canvas, .svg-container svg {
            max-width: 100%;
            max-height: 300px;
            object-fit: contain;
        }
        
        /* Button */
        .btn-download {
            display: block;
            width: 100%;
            max-width: 300px;
            margin: 0 auto;
            background-color: var(--secondary);
            color: #fff;
            border: none;
            padding: 15px;
            font-size: 1.1rem;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
            text-align: center;
            text-decoration: none;
        }
        .btn-download:hover {
            opacity: 0.9;
        }
        .btn-download.disabled {
            background-color: #ccc;
            cursor: not-allowed;
            pointer-events: none;
        }

        @media (max-width: 600px) {
            .preview-area {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>

<div class="container">
    <h1><i class="fa-solid fa-pen-nib"></i> 画像アウトライン変換ツール</h1>
    
    <div class="description">
        <strong>【使い方】</strong><br>
        1. 異体字や外字の画像（JPG/PNG）を選択してください。<br>
        2. 「しきい値」スライダーを動かして、文字がくっきり見えるように調整してください。<br>
        3. 「SVGを保存」ボタンを押すと、Excel等で使えるベクターデータとしてダウンロードされます。
    </div>

    <div class="controls">
        <div class="file-input-wrapper">
            <label style="font-weight:bold; font-size:0.9rem;">① 画像を選択</label>
            <input type="file" id="imageInput" accept="image/*">
        </div>
        <div class="range-wrapper">
            <label style="font-weight:bold; font-size:0.9rem;">② しきい値調整</label>
            <input type="range" id="thresholdRange" min="0" max="255" value="128">
            <span id="thresholdValue">128</span>
        </div>
    </div>

    <div class="preview-area">
        <div class="preview-box">
            <span class="preview-label">二値化処理 (Canvas)</span>
            <canvas id="processCanvas"></canvas>
            <p id="canvasPlaceholder" style="color:#aaa;">ここに画像が表示されます</p>
        </div>

        <div class="preview-box">
            <span class="preview-label">アウトライン結果 (SVG)</span>
            <div id="svgContainer" class="svg-container"></div>
            <p id="svgPlaceholder" style="color:#aaa;">変換結果が表示されます</p>
        </div>
    </div>

    <a id="downloadBtn" class="btn-download disabled">SVGを保存 (Excel用)</a>
</div>

<script>
    // --- 要素の取得 ---
    const imageInput = document.getElementById('imageInput');
    const thresholdRange = document.getElementById('thresholdRange');
    const thresholdValue = document.getElementById('thresholdValue');
    const processCanvas = document.getElementById('processCanvas');
    const ctx = processCanvas.getContext('2d');
    const svgContainer = document.getElementById('svgContainer');
    const downloadBtn = document.getElementById('downloadBtn');
    
    // プレースホルダー制御用
    const canvasPlaceholder = document.getElementById('canvasPlaceholder');
    const svgPlaceholder = document.getElementById('svgPlaceholder');

    // 状態管理
    let originalImage = null;

    // --- 1. 画像読み込み ---
    imageInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(event) {
            originalImage = new Image();
            originalImage.onload = function() {
                // キャンバスサイズを画像に合わせる
                processCanvas.width = originalImage.width;
                processCanvas.height = originalImage.height;
                
                // 初回描画＆変換実行
                updateCanvasAndVector();
                
                // UI更新
                canvasPlaceholder.style.display = 'none';
                svgPlaceholder.style.display = 'none';
                downloadBtn.classList.remove('disabled');
            };
            originalImage.src = event.target.result;
        };
        reader.readAsDataURL(file);
    });

    // --- 2. しきい値変更時の処理 ---
    thresholdRange.addEventListener('input', function(e) {
        thresholdValue.textContent = e.target.value;
        if (originalImage) {
            updateCanvasAndVector();
        }
    });

    // --- メイン処理関数 ---
    function updateCanvasAndVector() {
        if (!originalImage) return;

        // A. Canvasに描画して二値化（白黒化）
        ctx.drawImage(originalImage, 0, 0);
        
        // ピクセルデータを取得
        const imageData = ctx.getImageData(0, 0, processCanvas.width, processCanvas.height);
        const data = imageData.data;
        const threshold = parseInt(thresholdRange.value);

        // 全ピクセルを走査して二値化
        for (let i = 0; i < data.length; i += 4) {
            // グレースケール化 (重み付け平均)
            const brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
            
            // しきい値判定 (白か黒か)
            const color = brightness >= threshold ? 255 : 0;
            
            data[i] = color;     // R
            data[i + 1] = color; // G
            data[i + 2] = color; // B
            // Alphaはそのまま (data[i+3])
        }
        
        // 加工したデータをCanvasに戻す
        ctx.putImageData(imageData, 0, 0);

        // B. ImageTracer.jsでSVG化（ベクター変換）
        // オプション設定: ノイズ除去と精度を高める設定
        const options = {
            ltres: 1,       // 直線近似の許容誤差 (小さいほど詳細)
            qtres: 1,       // 曲線近似の許容誤差
            pathomit: 8,    // 小さすぎるパス(ノイズ)を除外 (ピクセル数)
            colorsampling: 0, // カラーサンプリング無効（独自に二値化したため）
            numberofcolors: 2, // 白と黒のみ
            mincolorratio: 0,
            colorquantcycles: 0,
            scale: 1,
            strokewidth: 0,
            linefilter: false 
        };

        // Canvasの画像データをSVG文字列に変換
        const svgString = ImageTracer.imagedataToSVG(imageData, options);
        
        // SVGを表示
        svgContainer.innerHTML = svgString;

        // SVG内のfill属性を調整（Excelで見やすくするため黒のみ残すなどの調整可）
        // ImageTracerは背景(白)もパスとして作ることがあるので、必要ならここで除去処理を入れるが、
        // 今回はシンプルにそのまま出力する。

        // C. ダウンロードリンクの作成
        const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        
        downloadBtn.href = url;
        // ファイル名: 元画像名 + .svg
        const originalName = imageInput.files[0] ? imageInput.files[0].name.split('.')[0] : "vector-image";
        downloadBtn.download = `${originalName}.svg`;
    }

</script>

</body>
</html>
